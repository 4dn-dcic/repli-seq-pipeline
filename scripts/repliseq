#!/bin/bash

usage() {
  >&2 echo "Usage (single-end): $(basename $0) [-t threads] -i bwaIndex"
  >&2 echo "  sample1_early.fastq[,sample2_early.fastq,sampleN_early.fastq   sample1_late.fastq[,sample2_late.fastq,sampleN_late.fastq]"
  >&2 echo ""
  >&2 echo ""
  >&2 echo "Usage (single-end): $(basename $0) [-t threads] -i bwaIndex"
  >&2 echo "  sample1_early_R1.fq,sample1_early_R2.fq[,sampleN_early_R1.fq,sampleN_early_R2.fq]  sample1_late_R1.fq,sample1_late_R2.fq[,sampleN_late_R1.fq,sampleN_late_R2.fq]"
  >&2 echo ""
  >&2 echo "bwaIndex (-i) can be a path to a bwa index prefix or a tarball of an bwa index"
  >&2 echo ""
  exit 1
}

################################
### PARSE COMMAND LINE ARGS ####
################################

while getopts ":i:t:m:w:r:p" opt; do
  case $opt in
  p)
   PAIRED=1
   ;;
  t)
   NTHREADS=$OPTARG
   ;;
  w)
   WINDOWSIZE=$OPTARG
   ;;
  i)
   INDEXFILE=$OPTARG
   ;;
  m)
   MEMPERTHREAD=$OPTARG
   ;;
  r)
   REFERENCE=$OPTARG
   ;;
  \?)
   echo "Invalid option: -$OPTARG" >&2
   usage
   ;;
  [?])
   usage
   ;;
  :)
   echo "Option -$OPTARG requires an argument." >&2
   echo "" >&2
   usage
   ;;
  esac
done

shift $((OPTIND-1))

if [ -z $NTHREADS ]; then
  NTHREADS=1
fi

if [[ -z $WINDOWSIZE ]]; then
  WINDOWSIZE=5000
fi

if [[ -z $MEMPERTHREAD ]]; then
  MEMPERTHREAD=5G
fi

if [[ -z $REFERENCE ]]; then
  >&2 echo "must define a normalization reference"
fi

if [[ -z $INDEXFILE ]]; then
  >&2 echo "must define an fasta or bwa index with -i"
fi

if [[ $# -lt 2 ]] ; then
  >&2 echo 'no fastq files specified'
  exit 1
fi

EF=$1
LF=$2

#check that dependencies are in PATH and correct versions
#check if chromsizes or fasta specified with -g
#check input files

if [[ -z $PAIRED ]]; then
  #todo: make sure length of EARLYBGS and LATEBGS is even
  #todo: check to see if read names in r1 and r2 are identical
#   ER1=$(echo $EF | tr ',' '\n' | paste - - | cut -f 1 | tr '\n' ',' | sed 's/,$//g')
#   ER2=$(echo $EF | tr ',' '\n' | paste - - | cut -f 2 | tr '\n' ',' | sed 's/,$//g')
#   LR1=$(echo $LF | tr ',' '\n' | paste - - | cut -f 1 | tr '\n' ',' | sed 's/,$//g')
#   LR2=$(echo $LF | tr ',' '\n' | paste - - | cut -f 2 | tr '\n' ',' | sed 's/,$//g')
  >&2 echo "paired-end not supported yet"
  exit 1
#   ER1=$(echo $ER1 | tr ' ' ',')
#   ER2=$(echo $ER2 | tr ' ' ',')
#   LR1=$(echo $LR1 | tr ' ' ',')
#   LR2=$(echo $LR2 | tr ' ' ',')

#   E=$(interleave -t $NTHREADS $ER1 $ER2)
#   L=$(interleave -t $NTHREADS $LR1 $LR2)
else
  E=$(echo $EF | tr ',' ' ')
  L=$(echo $LF | tr ',' ' ')
fi

# clip adapters from reads
cfq=$(clip $E $L)

# align reads to genome
bam=$(align -i $index $cfq)
bstat=$(samstats $bam)

# filter bams by alignment quality and sort by position
sbam=$(filtersort $bam)
fbstat=$(samstats $sbam)

# remove duplicate reads
rbam=$(dedup $sbam)

# calculate RPKM bedGraphs for each set of alignments
bg=$(count $rbam)

# filter windows with a low average RPKM
fbg=$(filter $bg)

# calculate log2 ratios between early and late
l2r=$(log2ratio $fbg)

# quantile-normalize replication timing profiles to the example reference bedGraph
l2rn=$(normalize $l2r)

# loess-smooth profiles using a 300kb span size
l2rs=$(smooth 300000 $NTHREADS $l2rn)


